<!DOCTYPE html>

<html lang="en" style="background:#050f05">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#070d07">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ObamaDash - London Temp</title>
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
  html { background:#050f05; height:100%; height:-webkit-fill-available; }
  body {
    width:100%; height:100%; height:-webkit-fill-available;
    min-height:100dvh; overflow:hidden;
    background:#050f05; color:#00cc33;
    font-family:'Share Tech Mono', monospace;
    font-size:11px; letter-spacing:0.5px;
    cursor:crosshair; -webkit-text-size-adjust:100%;
  }
  #app {
    display:flex; flex-direction:column;
    width:100%; height:100%; min-height:100dvh;
    background:#050f05; overflow:hidden; touch-action:none;
  }
  .bar {
    flex-shrink:0; display:flex; align-items:center; justify-content:space-between;
    padding:0 10px; height:24px; background:#070d07;
    color:#006618; font-size:10px; letter-spacing:2px; text-transform:uppercase;
  }
  .bar-top {
    border-bottom:1px solid #0f2a0f;
    padding-top:env(safe-area-inset-top);
    height:calc(24px + env(safe-area-inset-top));
  }
  .bar-bottom {
    border-top:1px solid #0f2a0f; padding-top:5px;
    padding-bottom:calc(env(safe-area-inset-bottom) + 5px);
    height:auto; min-height:24px; align-items:flex-start;
  }
  .bar-title { font-size:11px; letter-spacing:4px; color:#00cc33; text-transform:uppercase; white-space:nowrap; }
  .nav-link { color:#004a14; font-family:'Share Tech Mono',monospace; font-size:9px; letter-spacing:2px; text-decoration:none; margin-left:8px; }
  .price-display { color:#00cc33; font-size:11px; letter-spacing:1px; }
  .status-dot { width:5px; height:5px; border-radius:50%; background:#00cc33; flex-shrink:0; animation:pulse 2s infinite; }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.2} }
  .chart-controls {
    flex-shrink:0; display:flex; align-items:stretch;
    height:22px; background:#070d07; border-bottom:1px solid #0f2a0f;
  }
  .tf-btn {
    background:#070d07; border:none; border-right:1px solid #0f2a0f;
    color:#003a10; font-family:'Share Tech Mono',monospace;
    font-size:10px; letter-spacing:2px; text-transform:uppercase;
    padding:0 12px; cursor:pointer; transition:color 0.1s, background 0.1s;
  }
  .tf-btn.active { color:#00cc33; background:#0a160a; border-bottom:1px solid #00cc33; }
  .chart-shell { flex:1; min-height:0; display:flex; flex-direction:column; background:#050f05; }
  .chart-body { flex:1; position:relative; min-height:0; overflow:hidden; background:#050f05; touch-action:none; }
  #chart-container { width:100%; height:100%; background:#050f05; }

/* API key overlay */
#api-overlay {
position:absolute; inset:0; background:#050f05;
display:flex; flex-direction:column; align-items:center; justify-content:center;
gap:12px; z-index:100; padding:20px;
}
#api-overlay.hidden { display:none; }
.api-label { color:#006618; font-size:10px; letter-spacing:3px; text-transform:uppercase; text-align:center; }
.api-sub { color:#004a14; font-size:9px; letter-spacing:1px; text-align:center; line-height:1.6; }
.api-input {
background:#030803; border:1px solid #00cc33; color:#00cc33;
font-family:‘Share Tech Mono’,monospace; font-size:11px;
padding:8px 12px; width:100%; max-width:360px; text-align:center; letter-spacing:1px;
}
.api-input:focus { outline:none; border-color:#00ff41; }
.api-btn {
background:#030803; border:1px solid #00cc33; color:#00cc33;
font-family:‘Share Tech Mono’,monospace; font-size:10px;
letter-spacing:2px; padding:8px 24px; cursor:pointer;
}
.api-btn:active { background:#001a06; }
</style>

</head>
<body>
<div id="app">

  <div class="bar bar-top">
    <span class="bar-title">WX LONDON</span>
    <div style="display:flex;align-items:center;gap:6px">
      <a href="index.html" class="nav-link">BTC</a>
      <a href="backtest.html" class="nav-link">BT</a>
      <a href="forwardtest.html" class="nav-link">FT</a>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <span class="price-display" id="hdr-temp">--</span>
      <div class="status-dot"></div>
    </div>
  </div>

  <div class="chart-controls">
    <button class="tf-btn active" id="btn-ltf-ratio" onclick="switchMode('LTF_RATIO')">M1 RATIO</button>
    <button class="tf-btn"        id="btn-ltf-both"  onclick="switchMode('LTF_BOTH')">M1 BOTH</button>
    <button class="tf-btn"        id="btn-htf"       onclick="switchMode('HTF')">HTF</button>
    <button class="tf-btn" style="margin-left:auto;border-left:1px solid #0f2a0f;border-right:none" onclick="showApiOverlay()">KEY</button>
  </div>

  <div class="chart-shell">
    <div class="chart-body">
      <div id="chart-container"></div>
      <div id="api-overlay">
        <div class="api-label">Tomorrow.io API Key Required</div>
        <div class="api-sub">
          Sign up free at tomorrow.io<br>
          500 calls/day -- 1-minute historical data<br>
          No credit card needed
        </div>
        <input class="api-input" id="api-key-input" type="text" placeholder="Paste your API key here" autocomplete="off" autocorrect="off" spellcheck="false">
        <button class="api-btn" onclick="saveApiKey()">CONNECT</button>
        <div class="api-sub" id="api-error" style="color:#cc3300;display:none"></div>
      </div>
    </div>
  </div>

  <div class="bar bar-bottom">
    <span id="bar-status">LOADING...</span>
    <span id="bar-time">--</span>
  </div>

</div>
<script>
// -- CONFIG --------------------------------------------
const CFG = {
  lat: 51.5048, lon: 0.0495,   // London City Airport (EGLC)
  htfRatio: 60,                 // 1hr = 60 min (tune like BTC)
  angles: [27,45,60,72,78],
  refreshSec: 60,
};

let apiKey = ‘geHqAXyAgDTGlnyKJGK0wJX4RiBrpHeU’;
let chartMode = ‘LTF_RATIO’;
let lwChart, candleSeries, chartLevels = {};
let m1Candles = [], h1Candles = [];
let htfAnchorTs, ltfAnchorTs, htfAnchorOpen, ltfAnchorOpen;
let liveTimer = null;

// – ANCHORS —————————————––
// HTF = midnight UTC (daily open, equivalent of weekly open in BTC)
// LTF = 09:00 UTC (same as BTC)
function getMidnightUTC() {
const n = new Date();
return new Date(Date.UTC(n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate(), 0, 0, 0));
}
function get0900UTC() {
const n = new Date();
const a = new Date(Date.UTC(n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate(), 9, 0, 0));
if (a > n) a.setUTCDate(a.getUTCDate() - 1);
return a;
}

// – FAN MATH (identical to BTC) ———————–
function anglePrice(anchor, bars, deg, ratio) {
return anchor + bars * (ratio || 1) * Math.tan(deg * Math.PI / 180);
}

// – LEVEL COLOURS (identical to BTC) —————–
function getLevelDefs(type) {
const isRatio = type === ‘HTF_R’;
const h = type === ‘HTF’;
if (isRatio) return [
{label:‘EQ’,   deg:0,   color:’#ffffff’, width:1},
{label:’+27’,  deg:27,  color:’#ffb300’, width:1},
{label:’-27’,  deg:-27, color:’#ff00ff’, width:1},
{label:’+45’,  deg:45,  color:’#ffb300’, width:1},
{label:’-45’,  deg:-45, color:’#ff00ff’, width:1},
{label:’+60’,  deg:60,  color:’#ffb300’, width:1},
{label:’-60’,  deg:-60, color:’#ff00ff’, width:1},
{label:’+72’,  deg:72,  color:’#ffdd00’, width:1},
{label:’-72’,  deg:-72, color:’#ffdd00’, width:1},
{label:’+78’,  deg:78,  color:’#ffdd00’, width:1},
{label:’-78’,  deg:-78, color:’#ffdd00’, width:1},
];
return [
{label:‘EQ’,   deg:0,   color:h?’#ffffff’:’#aaaaaa’, width:1},
{label:’+27’,  deg:27,  color:h?’#00ff41’:’#00cc33’, width:1},
{label:’-27’,  deg:-27, color:h?’#ff3131’:’#cc2222’, width:1},
{label:’+45’,  deg:45,  color:h?’#00ff41’:’#00cc33’, width:1},
{label:’-45’,  deg:-45, color:h?’#ff3131’:’#cc2222’, width:1},
{label:’+60’,  deg:60,  color:h?’#00ff41’:’#00cc33’, width:1},
{label:’-60’,  deg:-60, color:h?’#ff3131’:’#cc2222’, width:1},
{label:’+72’,  deg:72,  color:h?’#ffb300’:’#dd9900’, width:1},
{label:’-72’,  deg:-72, color:h?’#ffb300’:’#dd9900’, width:1},
{label:’+78’,  deg:78,  color:h?’#ffb300’:’#dd9900’, width:1},
{label:’-78’,  deg:-78, color:h?’#ffb300’:’#dd9900’, width:1},
];
}

// – CHART BUILD (identical to BTC) —————––
function buildChart() {
const container = document.getElementById(‘chart-container’);
const body = container.parentElement;
function getH() { return body.getBoundingClientRect().height || window.innerHeight - 70; }
lwChart = LightweightCharts.createChart(container, {
width: container.clientWidth, height: getH(),
layout: { background:{color:’#050f05’}, textColor:’#006618’, fontSize:10 },
grid: { vertLines:{color:’#0c1a0c’,style:0}, horzLines:{color:’#0c1a0c’,style:0} },
crosshair: {
mode: LightweightCharts.CrosshairMode.Normal,
vertLine: {color:’#00ff4166’,width:1,style:3,labelBackgroundColor:’#051405’},
horzLine: {color:’#00ff4166’,width:1,style:3,labelBackgroundColor:’#051405’},
},
rightPriceScale: { borderColor:’#0f2a0f’, textColor:’#006618’, scaleMargins:{top:0.08,bottom:0.08} },
timeScale: { borderColor:’#0f2a0f’, timeVisible:true, secondsVisible:false },
localization: { priceFormatter: p => p.toFixed(2) + ‘C’ },
});
candleSeries = lwChart.addCandlestickSeries({
upColor:’#00ff41’, downColor:’#ff3131’,
borderUpColor:’#00ff41’, borderDownColor:’#ff3131’,
wickUpColor:’#00aa2a’, wickDownColor:’#aa1111’,
});
let _rt;
function dResize() { clearTimeout(_rt); _rt = setTimeout(() => lwChart.applyOptions({width:container.clientWidth,height:getH()}), 80); }
window.addEventListener(‘resize’, dResize);
if (window.visualViewport) window.visualViewport.addEventListener(‘resize’, dResize);
}

// – DRAW FAN LEVELS ———————————–
function clearChartLevels() {
for (const s of Object.values(chartLevels)) { try { lwChart.removeSeries(s); } catch(e){} }
chartLevels = {};
}

function drawLevelSet(candles, anchorTs, anchorOpen, type, ratio) {
if (!anchorOpen || !candles.length) return;
const defs = getLevelDefs(type);
const anchorSec = anchorTs.getTime() / 1000;
const secPerBar = (type === ‘HTF’ || type === ‘HTF_R’) ? 3600 : 60;
const filtered = candles.filter(c => c.time >= anchorSec);
if (filtered.length < 2) return;
const last = filtered[filtered.length - 1];
// Extend to end of today UTC
const endOfDay = new Date(Date.UTC(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate(), 23, 59, 0));
const endSec = endOfDay.getTime() / 1000;
const futureTs = [];
for (let t = last.time + 60; t <= endSec; t += 60) futureTs.push(t);

for (const def of defs) {
const data = filtered.map(c => ({
time: c.time,
value: anglePrice(anchorOpen, Math.floor((c.time - anchorSec) / secPerBar), def.deg, ratio || 1)
}));
for (const t of futureTs) {
data.push({ time: t, value: anglePrice(anchorOpen, Math.floor((t - anchorSec) / secPerBar), def.deg, ratio || 1) });
}
const prefix = type === ‘HTF_R’ ? ‘R’ : type === ‘HTF’ ? ‘H’ : ‘L’;
const s = lwChart.addLineSeries({
color: def.color, lineWidth: def.width,
lineStyle: type === ‘LTF’ ? 2 : 0,
priceLineVisible: false, lastValueVisible: true,
title: prefix + def.label, crosshairMarkerVisible: false,
});
s.setData(data);
chartLevels[`${type}_${def.label}`] = s;
}
}

function reloadLevels() {
clearChartLevels();
const candles = chartMode === ‘HTF’ ? h1Candles : m1Candles;
if (chartMode === ‘HTF’) {
if (htfAnchorOpen) {
drawLevelSet(candles, htfAnchorTs, htfAnchorOpen, ‘HTF’, 1);
drawLevelSet(candles, htfAnchorTs, htfAnchorOpen, ‘HTF_R’, CFG.htfRatio);
}
if (ltfAnchorOpen) drawLevelSet(candles, ltfAnchorTs, ltfAnchorOpen, ‘LTF’);
} else if (chartMode === ‘LTF_RATIO’) {
if (htfAnchorOpen) drawLevelSet(candles, htfAnchorTs, htfAnchorOpen, ‘HTF_R’, CFG.htfRatio);
if (ltfAnchorOpen) drawLevelSet(candles, ltfAnchorTs, ltfAnchorOpen, ‘LTF’);
} else if (chartMode === ‘LTF_BOTH’) {
if (htfAnchorOpen) {
drawLevelSet(candles, htfAnchorTs, htfAnchorOpen, ‘HTF’, 1);
drawLevelSet(candles, htfAnchorTs, htfAnchorOpen, ‘HTF_R’, CFG.htfRatio);
}
if (ltfAnchorOpen) drawLevelSet(candles, ltfAnchorTs, ltfAnchorOpen, ‘LTF’);
}
}

// – TOMORROW.IO FETCH ———————————
// Returns [{time (unix sec), open, high, low, close}] from minute data
async function fetchMinutes(hoursBack) {
const now = new Date();
const start = new Date(now.getTime() - hoursBack * 3600 * 1000);
const url = `https://api.tomorrow.io/v4/weather/history/recent`
+ `?location=${CFG.lat},${CFG.lon}`
+ `&fields=temperature`
+ `&timesteps=1m`
+ `&startTime=${start.toISOString()}`
+ `&endTime=${now.toISOString()}`
+ `&units=metric`
+ `&apikey=${apiKey}`;
const r = await fetch(url);
if (!r.ok) { const t = await r.text(); throw new Error(`${r.status}: ${t.slice(0,120)}`); }
const d = await r.json();
return tmrRowsToCandles(d, 60);
}

async function fetchHours(hoursBack) {
const now = new Date();
const start = new Date(now.getTime() - hoursBack * 3600 * 1000);
const url = `https://api.tomorrow.io/v4/weather/history/recent`
+ `?location=${CFG.lat},${CFG.lon}`
+ `&fields=temperature`
+ `&timesteps=1h`
+ `&startTime=${start.toISOString()}`
+ `&endTime=${now.toISOString()}`
+ `&units=metric`
+ `&apikey=${apiKey}`;
const r = await fetch(url);
if (!r.ok) { const t = await r.text(); throw new Error(`${r.status}: ${t.slice(0,120)}`); }
const d = await r.json();
return tmrRowsToCandles(d, 3600);
}

async function fetchForecastMinutes() {
const now = new Date();
const end = new Date(now.getTime() + 60 * 60 * 1000); // 1hr ahead (free tier max for minutely)
const url = `https://api.tomorrow.io/v4/weather/forecast`
+ `?location=${CFG.lat},${CFG.lon}`
+ `&fields=temperature`
+ `&timesteps=1m`
+ `&units=metric`
+ `&apikey=${apiKey}`;
const r = await fetch(url);
if (!r.ok) return [];
const d = await r.json();
return tmrRowsToCandles(d, 60);
}

async function fetchForecastHours() {
const url = `https://api.tomorrow.io/v4/weather/forecast`
+ `?location=${CFG.lat},${CFG.lon}`
+ `&fields=temperature`
+ `&timesteps=1h`
+ `&units=metric`
+ `&apikey=${apiKey}`;
const r = await fetch(url);
if (!r.ok) return [];
const d = await r.json();
return tmrRowsToCandles(d, 3600);
}

function tmrRowsToCandles(d, stepSec) {
// tomorrow.io response: d.timelines.minutely or d.timelines.hourly
// or d.data.timelines[0].intervals
let intervals = [];
try {
// history/recent format
if (d.data && d.data.timelines) {
intervals = d.data.timelines[0].intervals;
}
// forecast format
else if (d.timelines) {
const key = stepSec === 60 ? ‘minutely’ : ‘hourly’;
intervals = d.timelines[key] || [];
}
} catch(e) {}

if (!intervals.length) return [];

const rows = intervals.map(iv => ({
t: Math.floor(new Date(iv.startTime).getTime() / 1000),
temp: iv.values ? iv.values.temperature : iv.value
})).filter(r => r.temp !== null && r.temp !== undefined).sort((a,b) => a.t - b.t);

// Build OHLC candles: open = prev close, close = this temp, high/low = max/min(o,c)
const candles = [];
for (let i = 0; i < rows.length; i++) {
const o = i === 0 ? rows[i].temp : rows[i-1].temp;
const c = rows[i].temp;
candles.push({
time: rows[i].t,
open: o,
high: Math.max(o, c),
low:  Math.min(o, c),
close: c,
});
}
return candles;
}

// Merge historical + forecast, dedup by time
function mergeCandles(hist, forecast) {
const map = {};
for (const c of hist) map[c.time] = c;
for (const c of forecast) { if (!map[c.time]) map[c.time] = c; }
return Object.values(map).sort((a,b) => a.time - b.time);
}

function findAnchorOpen(candles, anchorTs) {
const sec = anchorTs.getTime() / 1000;
// Find the candle at or just after anchor time
const match = candles.find(c => Math.abs(c.time - sec) < 120);
return match ? match.open : (candles.length ? candles[0].open : null);
}

// – LOAD DATA —————————————–
async function loadAll() {
setStatus(‘FETCHING…’);
try {
htfAnchorTs = getMidnightUTC();
ltfAnchorTs = get0900UTC();

```
const [histM1, foreM1, histH1, foreH1] = await Promise.all([
  fetchMinutes(6),        // last 6 hrs M1
  fetchForecastMinutes(), // next 1hr M1
  fetchHours(24),         // last 24hrs H1
  fetchForecastHours(),   // next 5 days H1
]);

m1Candles = mergeCandles(histM1, foreM1);
h1Candles = mergeCandles(histH1, foreH1);

htfAnchorOpen = findAnchorOpen(h1Candles, htfAnchorTs);
ltfAnchorOpen = findAnchorOpen(m1Candles, ltfAnchorTs);

const current = m1Candles.length ? m1Candles.filter(c => c.time <= Date.now()/1000).pop() : null;
if (current) {
  document.getElementById('hdr-temp').textContent = current.close.toFixed(1) + 'C';
}

const candles = chartMode === 'HTF' ? h1Candles : m1Candles;
candleSeries.setData(candles);
reloadLevels();

// Set view
const visibleCandles = candles.filter(c => c.time <= Date.now()/1000);
if (visibleCandles.length) {
  const last = visibleCandles[visibleCandles.length - 1];
  lwChart.timeScale().setVisibleRange({
    from: last.time - (chartMode === 'HTF' ? 3600 * 12 : 60 * 90),
    to:   last.time + (chartMode === 'HTF' ? 3600 * 4  : 60 * 30),
  });
}

setStatus('LIVE - TOMORROW.IO');
document.getElementById('api-overlay').classList.add('hidden');
```

} catch(e) {
console.error(e);
setStatus(’ERROR: ’ + e.message.slice(0,40));
if (e.message.includes(‘401’) || e.message.includes(‘403’)) {
showApiOverlay(‘Invalid API key – check and retry’);
}
}
}

// Live 1-min update
function startLive() {
stopLive();
liveTimer = setInterval(async () => {
try {
const rows = await fetchMinutes(0.05); // last 3 mins
if (!rows.length) return;
const last = rows[rows.length - 1];
document.getElementById(‘hdr-temp’).textContent = last.close.toFixed(1) + ‘C’;
try { candleSeries.update(last); } catch(e){}
// sync m1Candles
if (m1Candles.length && m1Candles[m1Candles.length-1].time === last.time) {
m1Candles[m1Candles.length-1] = last;
} else if (last.time > (m1Candles[m1Candles.length-1]?.time || 0)) {
m1Candles.push(last);
}
document.getElementById(‘bar-time’).textContent = new Date().toUTCString().slice(5,22).toUpperCase() + ’ UTC’;
} catch(e){}
}, 60000); // every 60s (weather doesn’t change every second)
}
function stopLive() { if (liveTimer) { clearInterval(liveTimer); liveTimer = null; } }

// – SWITCH MODE —————————————
function switchMode(mode) {
chartMode = mode;
[‘ltf-ratio’,‘ltf-both’,‘htf’].forEach(id => document.getElementById(‘btn-’+id)?.classList.remove(‘active’));
if (mode === ‘LTF_RATIO’) document.getElementById(‘btn-ltf-ratio’)?.classList.add(‘active’);
if (mode === ‘LTF_BOTH’)  document.getElementById(‘btn-ltf-both’)?.classList.add(‘active’);
if (mode === ‘HTF’)       document.getElementById(‘btn-htf’)?.classList.add(‘active’);
const candles = mode === ‘HTF’ ? h1Candles : m1Candles;
if (candles.length) {
candleSeries.setData(candles);
reloadLevels();
}
}

// – API KEY OVERLAY ———————————–
function showApiOverlay(err) {
document.getElementById(‘api-overlay’).classList.remove(‘hidden’);
if (err) {
const el = document.getElementById(‘api-error’);
el.textContent = err;
el.style.display = ‘block’;
}
}
function saveApiKey() {
const k = document.getElementById(‘api-key-input’).value.trim();
if (!k) return;
apiKey = k;
localStorage.setItem(‘wx_api_key’, k);
document.getElementById(‘api-error’).style.display = ‘none’;
loadAll();
}

function setStatus(s) { document.getElementById(‘bar-status’).textContent = s; }

function updateClock() {
document.getElementById(‘bar-time’).textContent = new Date().toUTCString().slice(5,22).toUpperCase() + ’ UTC’;
}

// – BOOT ———————————————
window.addEventListener(‘load’, async () => {
buildChart();
requestAnimationFrame(() => setTimeout(() => window.dispatchEvent(new Event(‘resize’)), 150));
setInterval(updateClock, 1000);
document.getElementById(‘api-overlay’).classList.add(‘hidden’);
await loadAll();
setInterval(loadAll, CFG.refreshSec * 1000);
startLive();
});
</script>

</body>
</html>